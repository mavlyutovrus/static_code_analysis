from utils import *def get_line_offsets(source):    line_offsets = [len(line) + 1 for line in source.split("\n")]    for index in xrange(1, len(line_offsets)):        line_offsets[index] += line_offsets[index - 1]    line_offsets = [0] + line_offsets    return line_offsetsdef a_in_b(a, b):    return a[0] >= b[0] and a[1] <= b[1]class TNode:    def __init__(self, start, end, labels):        self.start = start        self.end = end        self.labels = set(labels)        self.children = []    def size(self):        return 1 + sum(child.size() for child in self.children)    def DFS(self, stack, func):        stack.append(self)        #print len(stack),        func(stack)        for child in self.children:            child.DFS(stack, func)        stack.pop()    def DFS1(self, stack, func):        stack.append(self)        #print len(stack),        go_deeper = func(stack)        if go_deeper:            for child in self.children:                child.DFS1(stack, func)        stack.pop()    def get_snippet(self, source):        return source[self.start:self.end]def markup2tree(markup):    used = set()    root = TNode(0, 1000000, set())    stack = [root]    intervals = markup.keys()    intervals = sorted(intervals, key=lambda interval : (interval[0], -interval[1]+interval[0],))    for interval in intervals:        while interval[0] >= stack[-1].end:            stack.pop()        node = TNode(interval[0], interval[1], set(markup[interval]))        stack[-1].children.append(node)        stack.append(node)    if root.size() != len(markup) + 1:        print "FUCKUP", root.size(), len(markup)        exit()    return rootclasses_by_pos = {}classes_info = {}class2varaibles = {}for line in open("all_classes_detailed_info.txt"):    fcn, extends, package, bounds, fname, imports = line[:-1].split("\t")    extends = extends.split("|")    imports = imports.split("|")    first, last = bounds[1:-1].split(", ")    first, last = int(first), int(last)    classes_info[fcn] = [extends, package, (first, last), fname, imports]    classes_by_pos.setdefault(fname, []).append((first, last, fcn))markup_by_file = {}if 1:    fname = ""    source = ""    line_offsets = []    markup = {}    count = 0    for markup_fname in ["all_files_markup2.txt", "all_files_markup.txt", "all_files_markup1.txt"]:        #if count > 100:        #    break        for line in open(markup_fname):            if line.startswith("FNAME:"):                count += 1                if count % 1000 == 0:                    print "..processed", count                if fname:# and fname == "/home/arslan/src/provenance/hadoop/hadoop-common-project/hadoop-annotations/src/main/java/org/apache/hadoop/classification/InterfaceAudience.java":                    markup_by_file[fname] = markup                markup = {}                fname = line.replace("FNAME:", "").strip()                source = open(fname).read()                line_offsets = get_line_offsets(source)                continue            delim = line.find("=")            coords, label = line[:delim], line[delim + 1: -1]            sline, scol, eline, ecol = [int(item) for item in coords.split(":")]            start = line_offsets[sline - 1] + scol - 1            end = line_offsets[eline - 1] + ecol            markup.setdefault((start, end), set()).add(label)    markup_by_file[fname] = markupdef get_path_to_text(text, root_node, source):    stack = [root_node]    while True:        added = False        for child in stack[-1].children:            if text in child.get_snippet(source):                stack.append(child)                added = True                break        if not added:            break    return stackprocessed = 0for fname, markup in markup_by_file.items():    processed +=1    if processed % 1000  == 0:        print "..processed", processed    source = open(fname).read()    markup_tree = markup2tree(markup)    class_defs = set()    def search_class_defs(node_stack):        if set(['body.ClassOrInterfaceDeclaration', 'body.AnnotationDeclaration',                'body.EnumDeclaration',                'body.ClassDeclaration',                'body.InterfaceDeclaration']) & node_stack[-1].labels:            class_defs.add(node_stack[-1])        return True    markup_tree.DFS1([], search_class_defs)    if class_defs and len(class_defs) != len(classes_by_pos[fname]):        print "DISCREPANCY", fname        exit()    matched_fcns = []    for class_node in class_defs:        fcns = []        for first, last, fcn in classes_by_pos[fname]:            diff =abs(first - class_node.start) + abs(last - class_node.end)            fcns.append((diff, fcn))        selected_fcn = min(fcns)[1]        #print min(fcns)        matched_fcns += [selected_fcn]        classes_info[selected_fcn].append(class_node)        classes_info[selected_fcn][2] = (class_node.start, class_node.end)    if len(matched_fcns) != len(set(matched_fcns)):        print "DOUBLE_MATCH", matched_fcns, fname        exit()output = open("all_classes_detailed_info_with_vars1.txt", "w")for fcn, data in classes_info.items():    if len(data) < 6:        print "skipped:", fcn, data[3]        continue    extends, package, (first, last), fname, imports, class_node = data    source = open(fname).read()    import re    class_snippet = class_node.get_snippet(source)    class_header_snippet = remove_comments(class_snippet)    if "{" in remove_interfaces(class_header_snippet):        class_header_snippet = remove_interfaces(class_header_snippet)    #class_header_snippet = class_header_snippet.split(" implements ")[0].split(" extends ")[0]    type_params_string = re.findall("<.+?>", class_header_snippet.split(" implements ")[0].split(" extends ")[0])    type_params_string = len(type_params_string) and type_params_string[0] or ""    type_params_string_offset = class_snippet.index(type_params_string) + class_node.start    class_type_params = []    if type_params_string:        for ch_node in class_node.children:            if ch_node.start > type_params_string_offset + len(type_params_string):                break            if ch_node.start < type_params_string_offset:                continue            if 'type.TypeParameter' in ch_node.labels:                class_type_params.append(ch_node.get_snippet(source))    if fcn == "org.apache.hadoop.io.serializer.DeserializerComparator":        print type_params_string        print class_header_snippet    """    if "<" in class_header_snippet:        print class_header_snippet.replace("\n", " ")        print type_params_string        print class_type_params        print "----"    """    output.write("\t".join([fcn, "|".join(extends), package, str(first), str(last), fname, "|".join(imports), "|".join(class_type_params)])  + "\n")    def all_nodes(node):        yield node        for ch_node in node.children:            for dec_node in all_nodes(ch_node):                yield dec_node    def grep_fields(nodes_stack):        if 'body.FieldDeclaration' in nodes_stack[-1].labels:            for node in all_nodes(nodes_stack[-1]):                output.write("\t" + "|".join(node.labels) + "\t" + str(node.start) + "\t" + str(node.end) + "\n")            output.write("---\n")            """            return False            decl_text = nodes_stack[-1].get_snippet(source)            sub_nodes = [node for node in all_nodes(nodes_stack[-1])]            type = [node.get_snippet(source) for node in sub_nodes \                    if sum("type." in label and 1 or 0 for label in node.labels)]            print "\tFIELD", decl_text            if not "=" in decl_text:                # private int numNMs, numRacks, numAMs, numTasks;                for subnode in all_nodes(nodes_stack[-1]):                    subnode_text = subnode.get_snippet(source)                    if not " " in subnode_text and not "<" in subnode_text and not subnode_text in type:                        name = subnode_text                        class_fields_decls[name] = (nodes_stack[-1], type[0])                        print "\tname:", name, "type:", type            else:                name = decl_text.replace("\n", " ").split(";")[0].split("=")[0].strip().split(" ")[-1]                class_fields_decls[name] = (nodes_stack[-1], type[0])                print "\tname:", name, "type:", type            """    class_node.DFS([], grep_fields)output.close()exit()exit()fuckers = [0]whole = set()processed = 0for fname, markup in markup_by_file.items():    processed +=1    source = open(fname).read()    markup_tree = markup2tree(markup)    def yield_parents(node_stack):        text = source[node_stack[-1].start: node_stack[-1].end]        #if "expr.NameExpr" in node_stack[-1].labels:        #    print node_stack[-1].labels, text, node_stack[-1].start, node_stack[-1].end        if "expr.NameExpr" in node_stack[-1].labels:            for node in node_stack:                start, end = node.start, node.end                if end -start < 500:                    print node.labels, "|||", source[start:end]            print "======"    def find_definition_local(path2target):        variable_name = source[path2target[-1].start : path2target[-1].end]        if variable_name == "this":            return ("this", "this")        print "VARIABLE:", variable_name, path2target[-1].labels        def next(stack):            change_pos = 0            while len(stack) >= 2:                previous = stack[-1]                stack.pop()                stop = False                for index in xrange(len(stack[-1].children)):                    if stack[-1].children[index] == previous:                        change_pos = index                        break                if change_pos > 0:                    break            change_depth = len(stack)            if change_pos == 0:                return (change_depth, stack)            stack.append(stack[-1].children[change_pos - 1])            while stack[-1].children:                stack.append(stack[-1].children[-1])            return (change_depth, stack)        min_depth = len(path2target)        method_text = ""        method_node = ""        for level in xrange(len(path2target)):            if set(["body.MethodDeclaration", 'body.ConstructorDeclaration']) & path2target[level].labels:                method_node = path2target[level]                method_text = method_node.get_snippet(source)                """                print method_text                for childIndex in xrange(len(path2target[level].children)):                    print source[path2target[level].children[childIndex].start: path2target[level].children[childIndex].end], "|||", path2target[level].children[childIndex].labels                print "======"                #exit()                """                min_depth = level + 1                break        class_fields_decls = {}        for level in xrange(len(path2target) - 1, -1, -1):            #print "track:",level, path2target[level].labels            if path2target[level].labels & set(['body.ClassOrInterfaceDeclaration', 'body.EnumDeclaration', 'body.ClassDeclaration', 'body.InterfaceDeclaration']):                class_node = path2target[level]                print "class declaration:", class_node.children[0].get_snippet(source)                def all_nodes(node):                    yield node                    for ch_node in node.children:                        for dec_node in all_nodes(ch_node):                            yield dec_node                def grep_fields(nodes_stack):                    if 'body.FieldDeclaration' in nodes_stack[-1].labels:                        decl_text = nodes_stack[-1].get_snippet(source)                        sub_nodes = [node for node in all_nodes(nodes_stack[-1])]                        type = [node.get_snippet(source) for node in sub_nodes \                                    if sum("type." in label and 1 or 0 for label in node.labels)]                        print "\tFIELD", decl_text                        if not "=" in decl_text:                            # private int numNMs, numRacks, numAMs, numTasks;                            for subnode in all_nodes(nodes_stack[-1]):                                subnode_text = subnode.get_snippet(source)                                if not " " in subnode_text and not "<" in subnode_text and not subnode_text in type:                                    name = subnode_text                                    class_fields_decls[name] = (nodes_stack[-1], type[0])                                    print "\tname:", name, "type:", type                        else:                            name = decl_text.replace("\n", " ").split(";")[0].split("=")[0].strip().split(" ")[-1]                            class_fields_decls[name] = (nodes_stack[-1], type[0])                            print "\tname:", name, "type:", type                class_node.DFS([], grep_fields)                break        #print "class_fields:", class_fields_decls.items()        declaration_found = False        change_depth = min_depth        while not declaration_found:            #print "step"            change_depth, path2target = next(path2target)            #print "--- ", change_depth, min_depth, path2target[change_depth].get_snippet(source)            if change_depth < min_depth:                break            print "current leaf: ", path2target[-1].get_snippet(source)            for depth in xrange(min_depth, len(path2target)):                #print "------- ", path2target[depth].get_snippet(source), path2target[depth].labels                if set(["stmt.CatchClause"]) & path2target[depth].labels:                    type_node = path2target[depth].children[0]                    name_node = path2target[depth].children[1]                    print "TYPE NODE:", type_node.get_snippet(source), "NAME NOE:", name_node.get_snippet(source)                    if name_node.get_snippet(source) == variable_name:                        declaration_found = True                        return (path2target[depth], type_node.get_snippet(source))                elif set(["expr.SimpleName", "expr.NameExpr"]) & path2target[depth].labels:                    text = source[path2target[depth].start:path2target[depth].end]                    if text == variable_name or text.replace("[]", "") == variable_name:                        print "> ", text, depth                        for expr_depth in xrange(min_depth, depth):                            #print ">> ", path2target[expr_depth].get_snippet(source)                            if "expr.VariableDeclarationExpr" in path2target[expr_depth].labels or 'body.Parameter' in path2target[expr_depth].labels:                                declaration_found = True                                return (path2target[expr_depth], path2target[expr_depth].children[0].get_snippet(source))                                #print "\t", path2target[expr_depth].labels                                #print "\t", source[path2target[expr_depth].start:path2target[expr_depth].end]                                break                        break        if not declaration_found:            if variable_name in class_fields_decls:                declaration_found = True                return class_fields_decls[variable_name]                #print "\t", variable_name, class_fields_decls[variable_name]        return (None, None)        """        if not declaration_found:            print "FUCKUPDFDFDFDSFDSFDSFDSF"            fuckers[0] += 1            if fuckers[0] > 10:                exit()        if not declaration_found and method_text and variable_name == "StorageType":            print method_text            print "====="            print source            print "====="            def search(node_stack):                print  node_stack[-1].get_snippet(source), node_stack[-1].labels                print "00000000"            method_node.DFS([], search)            exit()        """    def all_nodes(node):        yield node        for ch_node in node.children:            for dec_node in all_nodes(ch_node):                yield dec_node    def build_path(target_node, root_node):        stack = [root_node]        while stack[-1] != target_node:            for child in stack[-1].children:                if child.start <= target_node.start and child.end >= target_node.end:                    stack.append(child)                    break        return stack    def get_path_to_text(text, root_node):        stack = [root_node]        while True:            added = False            for child in stack[-1].children:                if text in child.get_snippet(source):                    stack.append(child)                    added = True                    break            if not added:                break        return stack    def get_type(node):        node_path = build_path(node, markup_tree)        print "Processing", node.get_snippet(source), node.start, node.end        if node.get_snippet(source)[0].isupper() or node.get_snippet(source)[0].istitle():            print "IS TYPE", node.get_snippet(source)            return        def_node, type_snippet = find_definition_local([node for node in node_path])        if not def_node:            print "FUCKUP"            print node_path[3].get_snippet(source)            print "processed:", processed, fname            #print "----"            if 1:                path = get_path_to_text("rawPayload.length", markup_tree)                for node in path[3:]:                    print node.labels, node.get_snippet(source)                    print "----"                """                for subnode in all_nodes(path[-1]):                    print subnode.labels, subnode.get_snippet(source)                    print "----"                """            exit()        return find_definition_local([node for node in node_path])    def decompose_method_call(node, offset=0):        snippet = node.get_snippet(source)        start_object = None        method_name_node = None        params_start_at = 0        if "expr.MethodCallExpr" in node.children[0].labels:            decompose_method_call(node.children[0])            method_name_node = node.children[1]            params_start_at = 2        else:            has_object = snippet.find(".") > 0 and snippet.find(".") < snippet.find("(")            if has_object:                start_object = node.children[0]                get_type(start_object)                method_name_node = node.children[1]                params_start_at = 2            else:                method_name_node = node.children[0]                params_start_at = 2        for param_node_index in xrange(params_start_at, len(node.children)):            param_node = node.children[param_node_index]            if 'expr.StringLiteralExpr' in param_node.labels:                continue            elif "expr.MethodCallExpr" in param_node.labels:                decompose_method_call(param_node)            elif 'expr.NameExpr' in param_node.labels or 'expr.SimpleName' in param_node.labels:                get_type(param_node)    def get_logs_recur(node_stack):        if "expr.MethodCallExpr" in node_stack[-1].labels:            text = node_stack[-1].get_snippet(source)            if text.startswith("LOG.debug") or text.startswith("LOG.warn") or text.startswith("LOG.info"):                log_line_elements = []                def get_log_line_elements(node_stack):                    if 'expr.FieldAccessExpr' in node_stack[-1].labels:                        log_line_elements.append(node_stack[-1].children[0])                        return False                    elif set(["expr.MethodCallExpr", 'expr.NameExpr', 'expr.SimpleName', 'expr.StringLiteralExpr']) & node_stack[-1].labels:                        log_line_elements.append(node_stack[-1])                        return False                    return True                for child in node_stack[-1].children[2:]:                    child.DFS1([], get_log_line_elements)                print text                for elem in log_line_elements:                    #print "\t", elem.labels, elem.get_snippet(source)                    if 'expr.StringLiteralExpr' in elem.labels:                        continue                    elif "expr.MethodCallExpr" in elem.labels:                        decompose_method_call(elem)                    elif 'expr.NameExpr' in elem.labels or 'expr.SimpleName' in elem.labels:                        get_type(elem)    markup_tree.DFS([], get_logs_recur)