from infer_type_mod import resolve_typefrom utils import *all_fcns = set()classes = []nodes = {}for line in open("all_classes_detailed_info_with_vars.txt"):    if line.startswith("\t"):        labels, start, end = line.strip().split("\t")        start, end = int(start), int(end)        nodes[(start, end)] = labels.split("|")    elif line.startswith("---"):        classes[-1][-1].append(markup2tree(nodes))        nodes = {}    else:        fcn, extents, package, first, last, fname, imports, type_params = line[:-1].split("\t")        all_fcns.add(fcn)        extents = extents and extents.split("|") or []        imports = imports and imports.split("|") or []        imports = [imp.replace("static ", "").strip()  for imp in imports]        for imp in imports:            if " " in imp:                print "\t", imp        type_params = type_params and type_params.split("|") or []        first, last = int(first), int(last)        classes += [[fcn, extents, package, first, last, fname, imports, type_params, []]]print "start"fcn_dict = {}for classes_index in xrange(len(classes)):    fcn, extents, package, first, last, fname, imports, type_params, variables = classes[classes_index]    fcn_dict[fcn] = [fcn, extents, package, first, last, fname, imports, type_params, variables]all_vars = []for classes_index in xrange(len(classes)):    fcn, extents, package, first, last, fname, imports, type_params, variables = classes[classes_index]    source = open(fname).read()    decoded_vars = {}    for variable_node in variables:        type_node = [node for node in variable_node.children                        if sum("type." in label and 1 or 0 for label in node.labels)][0]        while 'type.ArrayType' in type_node.labels:            type_node = type_node.children[0]        type = type_node.get_snippet(source)        type = type.split("<")[0]        type = "".join([chunk.strip() for chunk in type.split("\n")])        if not type or " " in type or "," in type:            print "FUCKUP"            exit()        only_var_names = variable_node.get_snippet(source)        only_var_names = only_var_names[type_node.end - variable_node.start:].split("=")[0].split(";")[0].split("//")[0].split("/*")[0]        only_var_names = only_var_names.replace("[]", "")        import re        var_names = [var_name for var_name in re.findall("[^\n\s\t,]+", only_var_names) if var_name and var_name != "[]"]        if "static" in var_names:            print var_names        """        if len(var_names) != 1:            print "CHECK", var_names            print "type:", type            #print "only vars:", only_var_names            print variable_node.get_snippet(source)            #print "type nodes:"            #for node in all_nodes(type_node):            #    print "\t", node.get_snippet(source), node.labels            print "----"        """        for var_name in var_names:            all_vars += [var_name]            decoded_vars[var_name] = type    classes[classes_index][-1] = decoded_varsprint "start1"processed = 0resolved = 0unresolved = 0out = open("all_classes_detailed_info_with_resolved_vars.txt", "w")for classes_index in xrange(len(classes)):    processed += 1    if processed % 1000 == 0:        print ".. processed", processed, "/", len(classes)    fcn, extents, package, first, last, fname, imports, type_params, variables = classes[classes_index]    extended_enxtents = set(extents)    layer = set(extents)    while layer:        new_layer = []        for extent in layer:            if extent in fcn_dict:                new_layer += fcn_dict[extent][1]        layer = set([extent for extent in  new_layer if extent in fcn_dict and not extent in extended_enxtents])        extended_enxtents = extended_enxtents | layer    extended_variables = []    source = open(fname).read()    for var_name, var_type in variables.items():        extended_var_type = resolve_type(var_type, fcn, extended_enxtents, package, first, last, fname, imports, type_params, fcn_dict)        if extended_var_type:            resolved += 1        else:            unresolved += 1            extended_var_type = var_type        extended_variables += [var_name + " " + extended_var_type]        """        if not extended_var_type:            print fcn, fname            for extent in extents:                print "-> ", extent                if extent in fcn_dict:                    print "\t", fcn_dict[extent][5]            print var_type, extended_var_type            print "extents:", extended_enxtents            print "type params:", type_params            print "similar:"            for other_fcn in fcn_dict.keys():                if other_fcn.endswith("." + var_type):                    print "\t\t", other_fcn, fcn_dict[other_fcn][5]            print "=-----="        """    out.write("\t".join([fcn, "|".join(extents), package, str(first), str(last),                         fname, "|".join(imports), "|".join(type_params), "|".join(extended_variables)]) + "\n")out.close()print resolved, unresolvedprint float(unresolved) / (resolved + unresolved)exit()fuckers = [0]whole = set()processed = 0for fname, markup in markup_by_file.items():    processed +=1    source = open(fname).read()    markup_tree = markup2tree(markup)    def yield_parents(node_stack):        text = source[node_stack[-1].start: node_stack[-1].end]        #if "expr.NameExpr" in node_stack[-1].labels:        #    print node_stack[-1].labels, text, node_stack[-1].start, node_stack[-1].end        if "expr.NameExpr" in node_stack[-1].labels:            for node in node_stack:                start, end = node.start, node.end                if end -start < 500:                    print node.labels, "|||", source[start:end]            print "======"    def find_definition_local(path2target):        variable_name = source[path2target[-1].start : path2target[-1].end]        if variable_name == "this":            return ("this", "this")        print "VARIABLE:", variable_name, path2target[-1].labels        min_depth = len(path2target)        method_text = ""        method_node = ""        for level in xrange(len(path2target)):            if set(["body.MethodDeclaration", 'body.ConstructorDeclaration']) & path2target[level].labels:                method_node = path2target[level]                method_text = method_node.get_snippet(source)                """                print method_text                for childIndex in xrange(len(path2target[level].children)):                    print source[path2target[level].children[childIndex].start: path2target[level].children[childIndex].end], "|||", path2target[level].children[childIndex].labels                print "======"                #exit()                """                min_depth = level + 1                break        class_fields_decls = {}        for level in xrange(len(path2target) - 1, -1, -1):            #print "track:",level, path2target[level].labels            if path2target[level].labels & set(['body.ClassOrInterfaceDeclaration', 'body.EnumDeclaration', 'body.ClassDeclaration', 'body.InterfaceDeclaration']):                class_node = path2target[level]                print "class declaration:", class_node.children[0].get_snippet(source)                def all_nodes(node):                    yield node                    for ch_node in node.children:                        for dec_node in all_nodes(ch_node):                            yield dec_node                def grep_fields(nodes_stack):                    if 'body.FieldDeclaration' in nodes_stack[-1].labels:                        decl_text = nodes_stack[-1].get_snippet(source)                        sub_nodes = [node for node in all_nodes(nodes_stack[-1])]                        type = [node.get_snippet(source) for node in sub_nodes \                                    if sum("type." in label and 1 or 0 for label in node.labels)]                        print "\tFIELD", decl_text                        if not "=" in decl_text:                            # private int numNMs, numRacks, numAMs, numTasks;                            for subnode in all_nodes(nodes_stack[-1]):                                subnode_text = subnode.get_snippet(source)                                if not " " in subnode_text and not "<" in subnode_text and not subnode_text in type:                                    name = subnode_text                                    class_fields_decls[name] = (nodes_stack[-1], type[0])                                    print "\tname:", name, "type:", type                        else:                            name = decl_text.replace("\n", " ").split(";")[0].split("=")[0].strip().split(" ")[-1]                            class_fields_decls[name] = (nodes_stack[-1], type[0])                            print "\tname:", name, "type:", type                class_node.DFS([], grep_fields)                break        #print "class_fields:", class_fields_decls.items()        declaration_found = False        change_depth = min_depth        while not declaration_found:            #print "step"            change_depth, path2target = next(path2target)            #print "--- ", change_depth, min_depth, path2target[change_depth].get_snippet(source)            if change_depth < min_depth:                break            print "current leaf: ", path2target[-1].get_snippet(source)            for depth in xrange(min_depth, len(path2target)):                #print "------- ", path2target[depth].get_snippet(source), path2target[depth].labels                if set(["stmt.CatchClause"]) & path2target[depth].labels:                    type_node = path2target[depth].children[0]                    name_node = path2target[depth].children[1]                    print "TYPE NODE:", type_node.get_snippet(source), "NAME NOE:", name_node.get_snippet(source)                    if name_node.get_snippet(source) == variable_name:                        declaration_found = True                        return (path2target[depth], type_node.get_snippet(source))                elif set(["expr.SimpleName", "expr.NameExpr"]) & path2target[depth].labels:                    text = source[path2target[depth].start:path2target[depth].end]                    if text == variable_name or text.replace("[]", "") == variable_name:                        print "> ", text, depth                        for expr_depth in xrange(min_depth, depth):                            #print ">> ", path2target[expr_depth].get_snippet(source)                            if "expr.VariableDeclarationExpr" in path2target[expr_depth].labels or 'body.Parameter' in path2target[expr_depth].labels:                                declaration_found = True                                return (path2target[expr_depth], path2target[expr_depth].children[0].get_snippet(source))                                #print "\t", path2target[expr_depth].labels                                #print "\t", source[path2target[expr_depth].start:path2target[expr_depth].end]                                break                        break        if not declaration_found:            if variable_name in class_fields_decls:                declaration_found = True                return class_fields_decls[variable_name]                #print "\t", variable_name, class_fields_decls[variable_name]        return (None, None)        """        if not declaration_found:            print "FUCKUPDFDFDFDSFDSFDSFDSF"            fuckers[0] += 1            if fuckers[0] > 10:                exit()        if not declaration_found and method_text and variable_name == "StorageType":            print method_text            print "====="            print source            print "====="            def search(node_stack):                print  node_stack[-1].get_snippet(source), node_stack[-1].labels                print "00000000"            method_node.DFS([], search)            exit()        """    def all_nodes(node):        yield node        for ch_node in node.children:            for dec_node in all_nodes(ch_node):                yield dec_node    def build_path(target_node, root_node):        stack = [root_node]        while stack[-1] != target_node:            for child in stack[-1].children:                if child.start <= target_node.start and child.end >= target_node.end:                    stack.append(child)                    break        return stack    def get_path_to_text(text, root_node):        stack = [root_node]        while True:            added = False            for child in stack[-1].children:                if text in child.get_snippet(source):                    stack.append(child)                    added = True                    break            if not added:                break        return stack    def get_type(node):        node_path = build_path(node, markup_tree)        print "Processing", node.get_snippet(source), node.start, node.end        if node.get_snippet(source)[0].isupper() or node.get_snippet(source)[0].istitle():            print "IS TYPE", node.get_snippet(source)            return        def_node, type_snippet = find_definition_local([node for node in node_path])        if not def_node:            print "FUCKUP"            print node_path[3].get_snippet(source)            print "processed:", processed, fname            #print "----"            if 1:                path = get_path_to_text("rawPayload.length", markup_tree)                for node in path[3:]:                    print node.labels, node.get_snippet(source)                    print "----"                """                for subnode in all_nodes(path[-1]):                    print subnode.labels, subnode.get_snippet(source)                    print "----"                """            exit()        return find_definition_local([node for node in node_path])    def decompose_method_call(node, offset=0):        snippet = node.get_snippet(source)        start_object = None        method_name_node = None        params_start_at = 0        if "expr.MethodCallExpr" in node.children[0].labels:            decompose_method_call(node.children[0])            method_name_node = node.children[1]            params_start_at = 2        else:            has_object = snippet.find(".") > 0 and snippet.find(".") < snippet.find("(")            if has_object:                start_object = node.children[0]                get_type(start_object)                method_name_node = node.children[1]                params_start_at = 2            else:                method_name_node = node.children[0]                params_start_at = 2        for param_node_index in xrange(params_start_at, len(node.children)):            param_node = node.children[param_node_index]            if 'expr.StringLiteralExpr' in param_node.labels:                continue            elif "expr.MethodCallExpr" in param_node.labels:                decompose_method_call(param_node)            elif 'expr.NameExpr' in param_node.labels or 'expr.SimpleName' in param_node.labels:                get_type(param_node)    def get_logs_recur(node_stack):        if "expr.MethodCallExpr" in node_stack[-1].labels:            text = node_stack[-1].get_snippet(source)            if text.startswith("LOG.debug") or text.startswith("LOG.warn") or text.startswith("LOG.info"):                log_line_elements = []                def get_log_line_elements(node_stack):                    if 'expr.FieldAccessExpr' in node_stack[-1].labels:                        log_line_elements.append(node_stack[-1].children[0])                        return False                    elif set(["expr.MethodCallExpr", 'expr.NameExpr', 'expr.SimpleName', 'expr.StringLiteralExpr']) & node_stack[-1].labels:                        log_line_elements.append(node_stack[-1])                        return False                    return True                for child in node_stack[-1].children[2:]:                    child.DFS1([], get_log_line_elements)                print text                for elem in log_line_elements:                    #print "\t", elem.labels, elem.get_snippet(source)                    if 'expr.StringLiteralExpr' in elem.labels:                        continue                    elif "expr.MethodCallExpr" in elem.labels:                        decompose_method_call(elem)                    elif 'expr.NameExpr' in elem.labels or 'expr.SimpleName' in elem.labels:                        get_type(elem)    markup_tree.DFS([], get_logs_recur)